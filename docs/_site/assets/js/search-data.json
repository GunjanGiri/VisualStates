{
  "1": {
    "id": "1",
    "title": "Examples",
    "content": "Example Behaviours Example robotic behaviours are developed in ROS Kinetic and Gazebo 9. The corresponding Github repository for the behaviors is VisualStates-examples",
    "url": "http://localhost:4000/docs/docs/examples",
    "relUrl": "/docs/examples"
  },
  "2": {
    "id": "2",
    "title": "Import Functionality",
    "content": "Import Functionality What is Import Functionality in VisualStates? A complex behavior of a robot consists of several states and tranisitions. Complex automata consists of parent child hierarchies with parent state representing a particular behavior developed using several child states. Say, for an example, the behavior ObstacleAvoidance is an automata and a parent state with Detect and Avoid as child states. The behavior takes the Laser data of robot as the input, processes it and decides tranisitions based on coniditions given by user and outputs the robot motion controls. Consider a case scenario in which a VisualStates user is developing a complex behavior which requires the obstacleAvoidance behavior as a child state. VisualStates provides the Import Functionality to import the exisiting behavior in the developing behavior. Rather then devloping the obstacleAvoidance behavior from scratch, user could import the prebuilt automata obstacleAvoidance into his StateSpace and alter the auxiliary functions and variables, conditions and sensor data according to the new robot. How to use VisualStates Import Functionality? Using the TreeView in VisualStates, navigate to the site where you want to import prebuilt behavior. Click on File -&gt; Import. Navigate FileManager to the VisualStates XML file of prebuilt behavior. Double Click the XML file and you would see the states and transitions are imported to your StateSpace. Edit the Robot configurations according to your robot using Actions -&gt; Config File. Following this, you have successfully imported the exisiting automata to your robot’s developing automata.",
    "url": "http://localhost:4000/docs/docs/user-manual/import/",
    "relUrl": "/docs/user-manual/import/"
  },
  "3": {
    "id": "3",
    "title": "Home",
    "content": "VisualStates It represents visually the robot’s behavior as a graph on a canvas composed of states (nodes,vertices) and transitions (edges, links). When the automaton is in a certain state it will pass from one state to another depending on the conditions established in the transitions. This graphical representation allows a higher level of abstraction for the programmer. It combines a graphical language to specify the states and the transitions with a text language (Python) to detail the behavior on each state or the conditions in the transitions. VisualStates generates a ROS node which implements the automata and shows a GUI at runtime with the active state every time, for debugging. Get started now View it on GitHub Getting started Installation from Ubuntu ROS Package If you have already installed ROS on your system, you can install visualstates with the following command. sudo apt install ros-kinetic-visualstates Installation from Source Install the following dependencies: ROS Kinetic Kame VisualStates is built as a Robotics Operating System package and currently developed using ROS Kinetic Kame. Follow the instructions given here to install ROS Kinetic on your desktop. sudo apt install ros-kinetic-desktop PyQT The frontend depends on PyQT to interactively develop robotic visual behavior. sudo apt install python-pyqt5 sudo apt install python-pyqt5.qsci The VisualStates tool is distributed as a ROS package. You can directly clone VisualStates repository in an active catkin workspace. Follow the steps below in your ROS workspace: cd catkin_ws/src git clone https://github.com/JdeRobot/VisualStates.git cd .. catkin_make source devel/setup.bash rosrun visualstates main.py About the project VisualStates is © 2017-2019 by JdeRobot. Contributing When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change. Read more about becoming a contributor in our GitHub repo. Code of Conduct VisualStates is committed to fostering a welcoming community. View our Code of Conduct on our GitHub repository.",
    "url": "http://localhost:4000/docs/",
    "relUrl": "/"
  },
  "4": {
    "id": "4",
    "title": "Introduction",
    "content": "VisualStates Usage Guide The VisualStates GUI has four sections: an upper menu bar, a treeView, SchemaView and dialogs for code and configs.   The menu bars contains the main buttons, which will allow you to do most of the actions. These buttons are: File button New: it allows you to start a new empty automata. It will close your actual automata if you had anyone open, and create a new empty subautomata for starting your new automata. Open: it allows you to open an existing automata and continue editing it. Save: it save the changes in the current path of the automata you are working with. If you did not saved yet, It will show up save as dialog. Save as: it allows you to save the automata as an xml file in the path you choose. This path will be the new path of your project, in case you press the button save. Quit: it exits the tool. If you have not save your change they will be lost. Figures button State: it allows you to create new states. For this, you must click the button and then click in the Schema wherever you want to place the new state. Ater that you can edit it. Nodes are represented as blue circles. Transition: it allows you to create new transitions. It works similar to the state button. You click it, and then, in the Schema view, you click the first node (state) origin and then the target one. If the target node is the same that the node origin, the tool will draw an autotransition. Transitions are represented as arrows pointing to the target node. Data button Timer: opens a window allowing you to modify the time of the loop. This means, you can vary the frequency of condition check. Variables: it pop up a window. You can define any variable you need in the nodes or transitions. Functions: you can also define your own functions, in case you need them. Functions have a global scope, both in python and in C++, while the variables you may declare has a local scope. They will only be seen in the subautomata where you are declaring them. In python, you can made them have a global scope by declaring them with “self.”, as then they will be a property of the python object automata. Actions button Libraries: it allows you to add any library you may need. You only have to put its name. Config file: it allow you to select the interfaces you may need in the code of states and transitions. You can first choose the type of the communication interface: JdeRobot Communication or ROS Nodpice. If you choose JdeRobot Communication you define your interfaces from given interface where you can set Server Type, Name, Topic, Proxy Name, IP, Port, Interface. If you choose ROS Node, you define package build dependencies and run dependencies under Package tab. You can choose your ROS topic interfaces from Topics tab. You can set the name of the topic, type of the topic and whether you would like to publish or subscribe to the topic. Generate C++ code: when clicking in this button, the tool will generate the C++ code of the automata saved CMakeLists.txt and the yml file with the interfaces that you have already defined if it is JdeRobot Communication interface. Otherwise, it will generate package.xml, CMakeLists.txt, python runtime codes and C++ code of the automata to the given catkin workspace. Generate python code: generate the python code of the automata and the yml file. It works in the same way as when clicking in Generate C++ code. It will leave the automata code in executable file .py. Now, looking at the Tree view, you can see that it displays two column: the node name and the node ID.I n the image, it is only displaying the nodes of the root subautomata, but the arrow next to its ID shows that these nodes also have sons. If you click on the arrow, the Tree view will expands and it will show this children also, so you can choose until which level do you want to see. Additionaly, you can use the Tree view for navigating through different subautomatas. If you do double click in a subautomata that you are not seeing now in the Schema view, it will redraw the Schema and show it. Finally, there is the Schema view. It allows you to add and edit states and transitions to your current subautomata for programming its behaviour. For adding new nodes, you just click in the menu on Figures/State, and then click on the Schema, and it will draw you a new node. If you make right click on it, you will have some options for editing it: Rename: allows you to change its current name. By default the name given is “state”. All states must have a different name. You can also rename your states if you double click on the name of the state. Code: it will pop up a new window where you can add the code that will be executed when this state is active. Mark initial: will set this node as the initial node of the subautomata. The initial nodes is the first node executed when the subautomata start for the first time. They are represented with a concentric circle. Copy: allows you to copy the node and then paste it in other place by doing right click/paste. Remove: it will erase this node and its transitions. Also, after you have created a transition, if you right click on the red handle of the transition it will also show some options for editing it: Rename: set a new name. Two transitions can have the same name. Code: Change the transition type. There are two types of transitions: temporal and conditional. If you set it as a temporal transition, then you must set a time (in milliseconds). After that time has passed, the node will stop of being active and the node pointed by this transition will be the active one. If you set the transition as conditional, then you must declare a boolean expression and the transition will take place when the expression is evaluated to true. If you choose conditional, you are going to write your conditional expression in the code editor at the bottom part of the dialog. Remove: it erase the transition. Additionally, if you want to create a subautomata son, then you must do double click on the node you want to be the father. Then the Schema will draw a new blank subautomata for adding the nodes and transitions you need, and they will appear in the Tree. For going back to the subautomata father you only have to click on the Up button, under the Tree. This button will redraw in the Scheme the current subautomata’s father or will not do anything if your subautomata does not have any parent. You can also use the Tree view for going to another subautomata. If you want to erase a subautomata, you must erase all its nodes and transitions, and then go to another subautomata (its father, for example). Execution of the Python created automaton When you press on generate python code, an executable python script and the .yml file will be created. Again, if you execute the script with the argument –displaygui=true, a runtime GUI will be shown. Its aspect is like the GUI of visualStates, but it does not have a menu bar, it only have the Schema and the Tree view just for visualization purposes. In this case, the GUI will not allow to edit any parameter, it just shows the active nodes allowing to visualize how the automata is working and if it goes from one state to another as we were expecting. In the Tree, the active node will be shown in green and the others in white, so you can see a resume of which nodes are actives in which subautomatas, all at the same time. In the Schema, there is only one subautomata drawn. Again, the active node will be coloured in green and the rest in blue. This section allow to see which node is active in the actual subautomata and if it transit to the state that it was supposed. The navigation is similar to the navigation in the visualStates GUI. You can go to one node child by double clicking on it and return to the current subatomata’s father by clicking on the button Up, or you can just make double click on the Tree over the subautomata you want to see.",
    "url": "http://localhost:4000/docs/docs/user-manual/intro/",
    "relUrl": "/docs/user-manual/intro/"
  },
  "5": {
    "id": "5",
    "title": "Kobuki Bump And Go",
    "content": "Kobuki Bump And Go The following example in VisualStates demonstrates the Obstacle Avoidance behavior developed for Kobuki-Turtlebot robot developed using ROS Kinetic and simulated in Gazebo9. The behavior consists of 3 states -&gt; Go, Rotate and GetBack and transitions based on the laser sensor data to detect a bump, rotate and move in different direction. Steps to run the example Dependencies We assume that you already installed ROS and Gazebo on Ubuntu 16.04 system to be able to test the behaviors. However, if you did not install yet, you can do so following these pages: http://wiki.ros.org/kinetic/Installation/Ubuntu http://gazebosim.org/tutorials?tut=install_ubuntu&amp;cat=install We also need worlds from JdeRobot repositories. To be able to install jderobot gazebo assets. Please follow the steps here: https://jderobot.org/Installation We add required commands here for completeness sudo sh -c &#39;cat&lt;&lt;EOF&gt;/etc/apt/sources.list.d/jderobot.list # for ubuntu 16.04 LTS (64 bit) deb [arch=amd64] http://jderobot.org/apt xenial main EOF&#39; sudo apt-key adv --keyserver keyserver.ubuntu.com --recv 24E521A4 sudo apt update sudo apt install jderobot-gazebo-assets To be able to complete the JdeRobot Gazebo assets installation we need to source the JdeRobot installation script source /opt/jderobot/share/jderobot/gazebo/gazebo-assets-setup.sh This is important that you need to run your gazebo simulation on the console that you have sourced your JdeRobot installation otherwise Gazebo simulator cannot find models and worlds of JdeRobot ROS package generation First we must generate the ros package of the behavior using the visualstates. rosrun visualstates main.py &lt;path_to_visualstates_examples&gt;/kobuki_bump_and_go/kobuki_bump_and_go.xml Using File -&gt; Save As save the behavior in a directory that is also in an active catkin_workspace. Since code generation will create required files to make the directory a ROS package, you should have different directory for every new behavior. Now, we can generate ROS package using Actions -&gt; Generate Python menu. Navigate to your catkin_workspace and run catkin_make. As an output of catkin_make you will see the kobuki_bump_and_go listed as a ROS package. cd catkin_ws catkin_make Start the roscore roscore Start the Gazebo simulator, using the gazebo_ros package rosrun gazebo_ros gazebo kobuki-simple-ros.world Run our generated package rosrun kobuki_bump_and_go kobuki_bump_and_go.py --displaygui=true",
    "url": "http://localhost:4000/docs/docs/examples/kobuki-bumpAndGo/",
    "relUrl": "/docs/examples/kobuki-bumpAndGo/"
  },
  "6": {
    "id": "6",
    "title": "Kobuki Obstacle Avoidance",
    "content": "Kobuki Obstacle Avoidance This behaviour demonstrates the Obstacle Avoidance behavior developed for Kobuki-Turtlebot robot developed using ROS Kinetic and simulated in Gazebo9. The behavior consists of 2 states -&gt; Move and Avoid and transitions based on the laser sensor data to detect and avoid obstacles like wall. Here’s a small demo video of the behaviour: Steps to run the example Dependencies We assume that you already installed ROS and Gazebo on Ubuntu 16.04 system to be able to test the behaviors. However, if you did not install yet, you can do so following these pages: http://wiki.ros.org/kinetic/Installation/Ubuntu http://gazebosim.org/tutorials?tut=install_ubuntu&amp;cat=install We also need worlds from JdeRobot repositories. To be able to install jderobot gazebo assets. Please follow the steps here: https://jderobot.org/Installation We add required commands here for completeness sudo sh -c &#39;cat&lt;&lt;EOF&gt;/etc/apt/sources.list.d/jderobot.list # for ubuntu 16.04 LTS (64 bit) deb [arch=amd64] http://jderobot.org/apt xenial main EOF&#39; sudo apt-key adv --keyserver keyserver.ubuntu.com --recv 24E521A4 sudo apt update sudo apt install jderobot-gazebo-assets To be able to complete the JdeRobot Gazebo assets installation we need to source the JdeRobot installation script source /opt/jderobot/share/jderobot/gazebo/gazebo-assets-setup.sh This is important that you need to run your gazebo simulation on the console that you have sourced your JdeRobot installation otherwise Gazebo simulator cannot find models and worlds of JdeRobot ROS package generation First we must generate the ros package of the behavior using the visualstates. rosrun visualstates main.py &lt;path_to_visualstates_examples&gt;/kobuki_obstacle_avoidance/kobuki_obstacle_avoidance.xml Using File -&gt; Save As save the behavior in an empty directory that is also in an active catkin_workspace. Since code generation will create required files to make the directory a ROS package, you should have different directory for every new behavior. Now, we can generate ROS package using Actions -&gt; Generate Python menu. Navigate to your catkin_workspace and run catkin_make. As an output of catkin_make you will see the kobuki_obstacle_avoidance listed as a ROS package. cd catkin_ws catkin_make Start the roscore roscore Start the Gazebo simulator, using the gazebo_ros package rosrun gazebo_ros gazebo kobuki-simple-ros.world Run our generated package rosrun kobuki_obstacle_avoidance kobuki_obstacle_avoidance.py --displaygui=true",
    "url": "http://localhost:4000/docs/docs/examples/kobuki-obstacle-avoidance/",
    "relUrl": "/docs/examples/kobuki-obstacle-avoidance/"
  },
  "7": {
    "id": "7",
    "title": "Namespace Functionality",
    "content": "Namespace Functionality What are Namespaces in VisualStates? VisualStates provides Global and Local Namespaces. Global Namespace consists all the functions, variables and the ROS nodes with publishers and subscribers which are required globally through the complex automata. Local Namespace consists functions and variables required by a particular state or transition or a group of states or transitions. Every level of automata consists of a Local Namespace where its local variables and functions can be defined. Why Namespaces? While developing complex behaviors, the states and transitions can have their own auxiliary data accessible by them only. Seperate Namespaces avoids the auxiliary data name conflicts. While developing automata, user may provide functions and variabes names which may conflict with other automata’s auxiliary data. While importing, existing auxiliary data might conflict with the importing automata i.e. the method and variables might collide, seperating them into Local Namespaces avoid the issue upto a great extent. How to use Namespaces in VisualStates while developing a complex behavior? Data -&gt; Global Namespace: Write all the global methods and variables which are required to be used throughout the behavior in all levels of automata. The Global Namespace would also contains all the ROS Publishers and Subscribers. Members can be accessed using self.globalNamespace.[method or variable name] anywhere in the whole automata. Data -&gt; Local Namespace: On the exisiting level of automata, all the states and transitions can access these methods and variables. Write all the local methods and variables which are required to be used on the current level of automata in states and transitions. On the same level, the local members can be accessed using self.localNamespace.[method or variable] to navigate through different local namespaces, navigate through different levels of automata using the TreeView provided in the VisualStates.",
    "url": "http://localhost:4000/docs/docs/user-manual/namespace/",
    "relUrl": "/docs/user-manual/namespace/"
  },
  "8": {
    "id": "8",
    "title": "Prius Crossing",
    "content": "Prius Crossing The following example in VisualStates demonstrates the Prius Toyota Car behavior at a crossing in Gazebo 9 developed through ROS Kinetic. The following examples illustrates the several functionalities of the tool. The example starts with prius on-road, waits for a person to cross, detects speed-limit sign, and then makes a left turn. The Prius car follows the road maintaining steer, break and throttle based on vision and control algorithm. The vision algorithm detects the lane in the camera using a pipeline of HSV color filteration followed by a P controller for steer and throttle control. Steps to run the example Dependencies We assume that you already installed ROS Kinetic and Gazebo 9 on Ubuntu 16.04 system to be able to test the behaviors. However, if you did not install yet, you can do so following these pages: http://wiki.ros.org/kinetic/Installation/Ubuntu http://gazebosim.org/tutorials?tut=install_ubuntu&amp;cat=install ROS Package Generation Copy Prius messages, world, description packages from PriusData and paste it in the ROS Workshop. Also clone the VisualStates package and copy the VisualStates prius_crossing.xml file which contains the crossing behavior. mkdir catkin_ws cd catkin_ws mkdir src cd src git clone https://github.com/JdeRobot/VisualStates.git cp -r &lt;path_to_visualstates_examples&gt;/prius/* . cp -r &lt;path_to_visualstates_examples&gt;/prius_crossing/* . cd .. The example requires opencv installed as cd .. catkin_make source devel/setup.bash Generate the ROS Package of the behavior using the visualstates. rosrun visualstates main.py /src/prius_crossing/prius_crossing.xml Generate ROS package using `Actions -&gt; Generate Python` menu. Recompile the ROS Workspace and you would find a new package prius_example in the package list. After compiling source the workspace again. source devel/setup.bash Add the Prius Crossing Environment model to Gazebo models by adding the following line to your environment variables. export GAZEBO_MODEL_PATH=/prius_gazebo/models:$GAZEBO_MODEL_PATH Start the Gazebo simulator and spawn Toyota Prius Car with Prius world, using the toyota prius world launch file roslaunch prius_gazebo prius_crossing.launch Run our generated ROS Node and visualize Toyota Prius Car Example Behavior. rosrun prius_crossing prius_crossing.py –displaygui=true",
    "url": "http://localhost:4000/docs/docs/examples/prius_crossing/",
    "relUrl": "/docs/examples/prius_crossing/"
  },
  "9": {
    "id": "9",
    "title": "Prius in the City",
    "content": "Prius in the City The following example in VisualStates demonstrates the Prius Toyota Car wandering in the city. The environment is developed and simulated in Gazebo 9 and ROS Kinetic. The city is ambiguous to uncertanities like a human crossing a road, a crossing with turns, a car which needs to be overtaken, stop signs, speed signs on the road. The developed behavior in VisualStates is adaptable to all these uncertanities. Steps to run the example Dependencies We assume that you already installed ROS Kinetic and Gazebo 9 on Ubuntu 16.04 system to be able to test the behaviors. However, if you did not install yet, you can do so following these pages: http://wiki.ros.org/kinetic/Installation/Ubuntu http://gazebosim.org/tutorials?tut=install_ubuntu&amp;cat=install We assume you have created a ROS Workspace, cloned the latest release of VisualStates, compiled and sourced the workspace. ROS Package Generation Copy Prius messages, world, description packages from Prius and paste it in your ROS Workshop. Also copy the pre-developed VisualStates XML File. In our case lets name it catkin_ws. cd catkin_ws cd src cp -r &lt;path_to_visualstates_examples&gt;/prius/* . cp -r &lt;path_to_visualstates_examples&gt;/prius_simulate/prius_simulate.xml . cp -r &lt;path_to_visualstates_examples&gt;/prius_in_city/* . cd .. Generate the ROS Package of the behavior using the visualstates. rosrun visualstates main.py /src/prius_simulate/prius_simulate.xml rosrun visualstates main.py /src/prius_overtake/prius_in_city.xml Generate ROS package using `Actions -&gt; Generate Python` menu. Recompile the ROS Workspace and you would find a new package prius_spawn in the package list. After compiling source the workspace again. source devel/setup.bash Add the CloverLeaf model to Gazebo models by adding the following line to your environment variables. export GAZEBO_MODEL_PATH=/prius_gazebo/models:$GAZEBO_MODEL_PATH Start the Gazebo simulator and spawn Toyota Prius Car with Prius world, using the toyota prius world launch file roslaunch prius_gazebo prius_city.launch Run our generated ROS Node and visualize Toyota Prius Car Spawn Behavior. rosrun prius_simulate prius_simulate.py –displaygui=true rosrun prius_overtake prius_in_city.py –displaygui=true",
    "url": "http://localhost:4000/docs/docs/examples/prius_in_the_city/",
    "relUrl": "/docs/examples/prius_in_the_city/"
  },
  "10": {
    "id": "10",
    "title": "Prius Obstacle Avoidance",
    "content": "Prius Obstacle Avoidance The following example in VisualStates demonstrates the Prius Toyota Car Obstacle Avoidance behavior in Gazebo 8 developed through ROS Kinetic. The following examples illustrates the Import Functionality present in VisualStates. The prebuilt behavior of ObstacleAvoidance for TurtleBot is imported and updated to be used for Prius Obstacle Avoidance behavior. Also, the child-states developed in PriusSpawn behavior are used to drive the car. Steps to run the example Dependencies We assume that you already installed ROS Kinetic and Gazebo 8 on Ubuntu 16.04 system to be able to test the behaviors. However, if you did not install yet, you can do so following these pages: http://wiki.ros.org/kinetic/Installation/Ubuntu http://gazebosim.org/tutorials?tut=install_ubuntu&amp;cat=install We assume you have created a ROS Workspace, cloned the latest release of VisualStates, compiled and sourced the workspace. ROS Package Generation Copy Prius messages, world, description packages from Prius and paste it in your ROS Workshop. Also copy the pre-developed VisualStates XML File. In our case lets name it catkin_ws. cd catkin_ws cd src cp -r &lt;path_to_visualstates_examples&gt;/prius/* . cp -r &lt;path_to_visualstates_examples&gt;/priusObstacleAvoidance/* . cd .. Compile the package and source it. catkin_make source devel/setup.bash Generate the ROS Package of the behavior using the visualstates. bash rosrun visualstates main.py /src/prius_obstacle_avoidance/prius_obstacle_avoidance.xml Generate ROS package using `Actions -&gt; Generate Python` menu. Recompile the ROS Workspace and you would find a new package prius_obstacle_avoidance in the package list. After compiling source the workspace again. bash source devel/setup.bash Add the CloverLeaf model to Gazebo models by adding the following line to your environment variables. export GAZEBO_MODEL_PATH=&lt;path_to_PriusSpawnExample&gt;/prius_gazebo/models:$GAZEBO_MODEL_PATH Start the Gazebo simulator and spawn Toyota Prius Car with Prius world, using the toyota prius world launch file roslaunch prius_gazebo prius_obstacle_avoid.launch Run our generated ROS Node and visualize Toyota Prius Car Obstacle Avoidance Behavior. rosrun prius_obstacle_avoidance prius_obstacle_avoidance.py --displaygui=true",
    "url": "http://localhost:4000/docs/docs/examples/prius_obstacle_avoidance/",
    "relUrl": "/docs/examples/prius_obstacle_avoidance/"
  },
  "11": {
    "id": "11",
    "title": "Prius Overtake",
    "content": "Prius Overtake The following example in VisualStates demonstrates the Prius Toyota Car Overtake behavior in Gazebo 9 developed through ROS Kinetic. Two prius cars are simulated through a PID controller. Steps to run the example Dependencies We assume that you already installed ROS Kinetic and Gazebo 9 on Ubuntu 16.04 system to be able to test the behaviors. However, if you did not install yet, you can do so following these pages: http://wiki.ros.org/kinetic/Installation/Ubuntu http://gazebosim.org/tutorials?tut=install_ubuntu&amp;cat=install We assume you have created a ROS Workspace, cloned the latest release of VisualStates, compiled and sourced the workspace. ROS Package Generation Copy Prius messages, world, description packages from Prius and paste it in your ROS Workshop. Also copy the pre-developed VisualStates XML File. In our case lets name it catkin_ws. cd catkin_ws cd src cp -r &lt;path_to_visualstates_examples&gt;/prius/* . cp -r &lt;path_to_visualstates_examples&gt;/prius_overtake/* . cd .. Generate the ROS Package of the behavior using the visualstates. rosrun visualstates main.py &lt;path_to_ros_workspace&gt;/src/prius_simulate/prius_simulate.xml rosrun visualstates main.py &lt;path_to_ros_workspace&gt;/src/prius_overtake/prius_overtake.xml Generate ROS package using Actions -&gt; Generate Python menu. Recompile the ROS Workspace and you would find a new package prius_spawn in the package list. After compiling source the workspace again. source devel/setup.bash Add the CloverLeaf model to Gazebo models by adding the following line to your environment variables. export GAZEBO_MODEL_PATH=&lt;path_to_example&gt;/prius_gazebo/models:$GAZEBO_MODEL_PATH Start the Gazebo simulator and spawn Toyota Prius Car with Prius world, using the toyota prius world launch file roslaunch prius_gazebo prius_overtake.launch Run our generated ROS Node and visualize Toyota Prius Car Spawn Behavior. rosrun prius_simulate prius_simulate.py --displaygui=true rosrun prius_overtake prius_overtake.py --displaygui=true",
    "url": "http://localhost:4000/docs/docs/examples/prius_overtake/",
    "relUrl": "/docs/examples/prius_overtake/"
  },
  "12": {
    "id": "12",
    "title": "Robotic Arm",
    "content": "Robotic Arm The following example focuses on the hierarchies of automatas. The basic idea is to use predeveloped states to develop more complex behaviours. The example contains the following states - DrawI (Simple State with Letter I) DrawLove (Complex State with Letters L,O,V,E) DrawJdeRobot (Complex State with Letters J,D,E,R,O,B,O,T) Hence we need low level states with letters from A to Z to generate any behavior which contains letters. The low level states contains the Robotic Arm code to drive the ARM to write letters. For example, State drawA would contain robot code to draw letter A. Hence using hierarchies of these states we can develop complex states, i.e complex words/sentences. With a library of all 26 letters, we can Import the states(words) and construct any word/sentences. Steps to run the example Dependencies OpenCV VisualStates We assume you have created a ROS Workspace, cloned the latest release of VisualStates, compiled and sourced the workspace. ROS Package Generation Copy the robot_arm folder as a ROS package to your workspace. In our case we name it ‘catkin_ws’ cd catkin_ws cd src cp -r &lt;path_to_visualstates_examples&gt;/robot_arm/* . cd .. Generate the ROS Package of the behavior using the visualstates. rosrun visualstates main.py &lt;path_to_ros_workspace&gt;/src/robot_arm/robot_arm.xml Generate ROS package using Actions -&gt; Generate Python menu. Recompile the ROS Workspace and you would find a new package robot_arm in the package list. After compiling, source the workspace again. catkin_make source devel/setup.bash Start roscore and run the generated ROS Node with Visualization Flag as True. roscore rosrun robot_arm robot_arm.py --displaygui=true",
    "url": "http://localhost:4000/docs/docs/examples/robot_arm/",
    "relUrl": "/docs/examples/robot_arm/"
  },
  "13": {
    "id": "13",
    "title": "Tutorials",
    "content": "Tutorials How to develop robotic behaviors using VisualStates tool.",
    "url": "http://localhost:4000/docs/docs/tutorials",
    "relUrl": "/docs/tutorials"
  },
  "14": {
    "id": "14",
    "title": "User Manual",
    "content": "User Manual",
    "url": "http://localhost:4000/docs/docs/user-manual/user-manual/",
    "relUrl": "/docs/user-manual/user-manual/"
  }
  
}
